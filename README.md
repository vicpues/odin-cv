# Résumez App

A web app to create and edit your own résumé. [Check out the site here!](https://reesumez.netlify.app/)

This was an assignment for [The Odin Project](https://www.theodinproject.com/lessons/node-path-react-new-cv-application)'s fullstack javascript webdev course.

![Résumé editor](./src/assets/images/app-preview.jpg)

## How to use

Enter your info in the inputs and the résumé will update automatically. On mobile, you can switch between editing and previewing the résumé with the arrow at the bottom of the screen.

Under "Education" and "Work experience", you can add extra entries with the "+" button, or delete an entry with the "x" button.

## Planned features

If I can be bothered to keep up development, you can expect these major features:

- Download and print your résumé as a PDF
- Save your data so you can continue editing where you last left off
- Reorder your work/education entries by date.
- Extra layouts so you can customize the look of your résumé
- Add photos to your document
- Extra languages

## Development log

Well, there it is! Honestly, even though it took longer than any previous project (>2 weeks!), time really flew by. I think it's because I'm getting better at modular design, and that makes problems seem a lot more approachable. Also, having a design system with variables made the UI _waay_ less painful to implement. Huge thanks to [Sajid on YouTube](https://www.youtube.com/@whosajid), his videos finally unlocked design systems for me.

The point of this assignment was to get my feet wet with react's state functionality, and I found it reasonably easy to use. Well, even if my solution was a little hacky (With so many inputs, I ended up using multiple forms to keep the central state both flat, and extendable). I really like how I can use jsx to crank out components quickly, and sprinkle in some vanilla js here and there to get fine-grained control over certain elements.

Another thing that made development easier was my yarn + react template (currently private). It took a whole day to write, but applying it to this project was totally seamless. I didn't have to fiddle with yarn's rough edges, and the boilerplate generated by vite was already minimised

There _was_ one rabbit hole I didn't anticipate: webfonts. This time around, I really wanted to try a variable font, but I discovered that most online generators strip off the variable features when converting fonts to WOFF. I couldn't find one that did both subsetting **and** variable axes, so I ended up using two different converters. I gave up and went with that inefficient option, but I really want to dig deeper and find a build tool that takes a raw .ttf, converts it to .woff/.woff2, and does custom subsetting without destroying the variable features. If I can't find it for the next project, I might just have to write it myself (!!)

This was also my first deployment using Netlify instead of Github pages. Not much to report there; I was hoping to learn a bit about CI by trying out a different service, but Netlify's CI automation is so painless that I didn't really learn anything lol. Maybe I'll switch back to github pages and replace my hacky dist script with a workflow. Or maybe I'll try Vercel or Cloudflare, see if they're better for learning the ropes.

To cap this devlog off, I wanna say that this was a fun project to work on! I'd love to keep adding features, but maybe it's time to move on. I think I'll show the app to my friends and implement some of their input. If they show interest, _maaaybe_ I'll actually add the extra features I had planned. Maybe.

## Technologies used

### Frontend libraries

- React
- Mdi Icons

### Styling and linting

- ESLint
- Stylelint
- Prettier
- PostCSS

### Build Tools

- Vite

### Package management

- Yarn

### Deployment

- Netlify web app

### Version control

- Git
- Github
- Husky (for pre-commit hooks)

## Contributing

If you wanna contribute to this, you rock.

### Installation

The only required software is Yarn. Just clone the project and run this in the project directory to install the dependencies and configure the sdks + precommit hooks:

```bash
yarn ; yarn setup
```

If it complains about esbuild or something, just run it again.

### Scripts

The package.json scripts are pretty self explanatory. If it's not listed here, it's a helper script and there's no reason to run it:

- `yarn setup`: Sets up husky and the editor after the dependencies have been installed. Only needed when you clone the project.
- `yarn fmt`: Runs prettier on the source files (see precommit hook below).
- `yarn lint`: Finds problems in the source files with eslint and stylelint.
- `yarn dev`: Spins up a vite development server.
- `yarn build`: Builds the project locally in `./dist`. Since the app is deployed automatically when `origin/main` updates, this is only necessary if you wanna test the performance of the app locally with `yarn preview`.

### Commits

I use the [conventional commits guidelines](https://www.conventionalcommits.org/en/v1.0.0/) for commit messages. The commits are not auto-linted, I trust you to follow them. Additional info is optional. Just remember to `yarn lint` before you merge.

There's a precommit hook that automatically formats your code when you commit. It remembers the files you've added to git, formats all the source files, and then commits _only_ the files that were already staged to git. This is so you can add individual files in each commit. This can break git in some cases, such commits that delete/rename files. If git starts acting out, you can bypass this behaviour with:

```bash
yarn fmt ; git add . ; git commit --no-verify
```
